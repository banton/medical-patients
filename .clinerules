# Cline's Project Intelligence (.clinerules)

## Project: Medical Patients Data System

*This file captures important patterns, preferences, and project intelligence that help Cline work more effectively on this specific project. It's a living document that grows as the project evolves.*

### Initial Observations & Rules:

1.  **Memory Bank First:** Always read and update the Memory Bank files (`memory-bank/*.md`) at the start of a session and after significant changes. This is crucial for maintaining context.
2.  **File Structure Awareness:** The project has a Python backend (`app.py`, `patient_generator/`) and a frontend. The frontend includes:
    *   A static HTML/JS application (`static/index.html`).
    *   An advanced visualization dashboard (`static/visualizations.html`) powered by a React/TSX component (`enhanced-visualization-dashboard.tsx`) which is compiled to `static/dist/bundle.js`. This part of the frontend uses Node.js, npm, `esbuild`, Jest, etc.
3.  **Python Focus:** The core data generation logic resides in Python modules. Pay attention to Python best practices, dependencies (`requirements.txt`), and packaging (`setup.py`). Backend APIs are built with FastAPI.
4.  **Iterative Documentation:** The Memory Bank files are now comprehensive and detailed, reflecting a mature project state. They should continue to be updated iteratively as the project evolves or new insights are gained.
5.  **User Interaction:** The presence of `static/index.html` implies user interaction. Consider how backend changes might affect the frontend experience.
6.  **Patient Data Core:** The `patient_generator` module is central. Understand its sub-modules (`demographics.py`, `fhir_generator.py`, etc.) and their roles.

### Tool Usage Patterns:

*   **Docker Compose Command:** If `docker-compose` (hyphenated) results in a "command not found" error, use `docker compose` (with a space) instead. This is common for newer Docker versions where Compose is integrated as a plugin.
*   **Frontend Testing:** Use `npm test` to run Jest tests for `.tsx` files. Configuration is in `jest.config.js`, `tsconfig.json`, and `setupTests.ts`.
*   **Frontend Build:** Use `npm run build` to compile `enhanced-visualization-dashboard.tsx` to `static/dist/bundle.js` using `esbuild`.

### User Preferences & Workflow:

*   **Backend Server Restarts:** When changes are made to Python backend code (`app.py` or imported modules), the Uvicorn server (especially if running in Docker without live reload for Python, or if not using `--reload` flag locally) MUST be restarted for changes to take effect. This was critical for resolving API 404 errors.
*   User manually verifies application behavior in the browser after changes.

### Known Challenges & Considerations:

*   **Cross-Stack Debugging:** Issues can span the frontend (React/TSX), backend (Python/FastAPI), and the build/serving pipeline. Debugging requires checking browser console, network tab, and backend server logs.
*   **API Data Consistency:** Ensure data structures returned by backend APIs match the interfaces/expectations of the frontend components (e.g., `JobSummary` interface and `/api/visualizations/job-list` payload).
*   **Python Type Errors:** Subtle type mismatches in Python (e.g., `datetime.date` vs `datetime.datetime` in lists to be sorted) can lead to 500 Internal Server Errors that manifest as data loading failures in the frontend. Careful and consistent type handling in Python data processing is crucial.
*   **JSDOM Limitations:** Frontend tests running in JSDOM may require mocks for browser-specific APIs not present (e.g., `ResizeObserver` for `recharts`).
*   **React Testing Library `act()` Warnings:** Asynchronous operations in `useEffect` can lead to `act()` warnings if not carefully managed in tests. Making fetch mocks explicitly asynchronous (e.g., with `setTimeout`) can help resolve these.
*   **Frontend Bundle Size:** The compiled `bundle.js` for the enhanced dashboard can become large if all dependencies are bundled. Consider externalizing large libraries (React, Recharts) and using CDNs for production optimization.
*   Maintaining consistency across all Memory Bank files.
*   Ensuring `.clinerules` accurately reflects the evolving project intelligence.
